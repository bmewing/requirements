% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rip_freeze.R
\name{rip_freeze}
\alias{rip_freeze}
\alias{generate_requirements}
\title{Generate a requirements.txt for your project}
\usage{
rip_freeze(output_path = "requirements.txt", eq_sym = ">=",
  inspect_files = c("R", "Rmd", "Rpres", "lock"), path = ".",
  recursive = TRUE, rm_missing = FALSE)

generate_requirements(output_path = "requirements.txt", eq_sym = ">=",
  inspect_files = c("R", "Rmd", "Rpres", "lock"), path = ".",
  recursive = TRUE, rm_missing = FALSE)
}
\arguments{
\item{output_path}{String indicating where to write resulting requirements file to.}

\item{eq_sym}{The equality symbol to be used when writing requirements (i.e. package>=1.0.0).
Use \code{NULL} to not include package versions in your requirements file.}

\item{inspect_files}{Character vector of file extensions to search for dependencies in.
Officially supports the following extensions: `c("R", "Rmd", "Rpres", "lock")`.
Other extensions will be processed as if they were `.R` files.}

\item{path}{Location where extensions from `inspect_files` should be searched for.
(see `path` from `?list.files`).}

\item{recursive}{Should the seatch for `inspect_files` recurse into directories?
(see `recursive` from `?list.files`).}

\item{rm_missing}{Should packages not installed locally be excluded from output?}
}
\value{
Nothing is returned.  Results are written to \code{output_path}
}
\description{
Generate a requirements file from existing file(s) and installed packages
}
\details{
If `"lock"` is included in `inspect_files`, it is assumed to refer to a `packrat.lock`.  Only files matching the
pattern `glob2rx("*packrat/packrat.lock")` will be considered.

Methodology for package matching relies on string pattern matching rather than a more sophisticated method.
This will match most 'standard' ways of referencing libraries in R code.
The following lines of code show examples where the \code{data.table} package will be matched properly:
\itemize{
  \item \code{library(data.table)}
  \item \code{library("data.table")}
  \item \code{library(data.table, warn.conflicts = TRUE)}
  \item \code{require(data.table)}
  \item \code{require("data.table")}
  \item \code{require(data.table, quietly = TRUE)}
  \item \code{pacman::p_load(data.table)}
  \item \code{pacman::p_load("data.table")}
  \item \code{pacman::p_load(data.table, install = FALSE)}
  \item \code{data.table::data.table()}
  \item \code{data.table:::data.table()}
}

Matching will fail if:

\itemize{
  \item loading multiple packages with \code{pacman::p_load} (only the first package will be matched)
  \item using a character vector to load; e.g. \code{pkg = "testthat"; library(pkg, character.only = TRUE)}
    (will match \code{pkg} as package instead of \code{testthat})
  \item using a string resembling a package load; e.g. \code{"library(fake.package)"}
    (will match \code{fake.package})
}
}
\examples{

\dontrun{
rip_freeze("R/*.R")
rip_freeze("R/*.R", output_path = "my_requirements.txt")
rip_freeze("R/*.R", output_path = "equal_to_requirements.txt", eq_sym = "==")
rip_freeze("R/*.R", output_path = "versionless_requirements.txt", eq_sym = NULL)
rip_freeze("R/*.R", output_path = "installed_requirements.txt", rm_missing = TRUE)
}
}
